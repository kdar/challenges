package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
)

var (
	TEST = `011000101000010011001110010001011110010111110111000111111101101010010011000001110010010100010110100011101010001101001100010001000111110100010110000001010101000110000111100110010001111010000001011110101100010000100111001111010000100111000010011111001000001111001111100111111011100111011001011000110111111000111110110000110101111100000110010101010100100010001010001011011000011111110111010100001000101010110111001010111100000101011011001001000011000010110010010100001010010110101111110010000000110110110000100011101111001001111010101010001110110000010111001010100100110101100100110111001010100110
010110001011010000001011011011110010001110010100011010001110000010110000111101000111101010000100110110111110011000100000100010111100001010110111100111011000111001010101111001111011111101000011001101101100110110011011110110011010010000101100100101011101001010000100010011111011100001100000010111010010100000011001010010101001010110111100011001001100010000111001100011110001110000011110001011110111000100010011000100011010011110100001110111101111011000111010111101111010010111010111011000100011101001101010011011000011000011011101011011000110100101011110100010011000010010001110100110000000000000`
)

func solve(input io.Reader) {
	scanner := bufio.NewScanner(input)
	scanner.Scan()
	A := []byte(scanner.Text())
	scanner.Scan()
	B := []byte(scanner.Text())

	if bytes.Count(A, []byte("1")) != bytes.Count(B, []byte("1")) {
		fmt.Println("-1")
		return
	}

	swaps := 0
	for i := 0; i < len(A); i++ {
		if A[i] != B[i] {
			for j := i + 1; j < len(A); j++ {
				if A[j] != B[j] && B[i] != B[j] {
					swaps++
					B[i], B[j] = B[j], B[i]
					break
				}
			}
		}
	}

	fmt.Println(swaps)
}

func main() {
	if len(os.Args) > 1 && os.Args[1] == "test" {
		solve(strings.NewReader(TEST))
		return
	}

	solve(os.Stdin)
}
